name: CI/CD Pipeline - MangeTaMain

on:
  push:
    branches: [ '**' ]  # Triggers on all branches
  pull_request:
    branches: [ main, develop ]

# Permissions n√©cessaires pour GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write
  actions: read

jobs:
  # ============================================
  # JOB 0: PREPARE - Setup Python & Poetry
  # ============================================
  prepare:
    name: Prepare Environment
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache Poetry installation
        id: cache-poetry
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install Poetry
        if: steps.cache-poetry.outputs.cache-hit != 'true'
        run: |
          curl -sSL https://install.python-poetry.org | python3 -

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify Poetry installation
        run: poetry --version

  # ============================================
  # JOB 1: LINT - Preprocessing
  # ============================================
  lint-preprocessing:
    name: Lint Preprocessing
    runs-on: ubuntu-latest
    needs: [prepare]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Restore Poetry from cache
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: poetry-deps-preprocessing-${{ hashFiles('preprocessing/poetry.lock') }}
          restore-keys: |
            poetry-deps-preprocessing-

      - name: Update lock file if needed
        working-directory: ./preprocessing
        run: poetry lock --no-interaction

      - name: Install dependencies
        working-directory: ./preprocessing
        run: poetry install --no-root

      - name: Run flake8
        working-directory: ./preprocessing
        run: |
          poetry run flake8 . --count --max-line-length=120 --statistics --exclude=.venv,__pycache__,*.pyc,.git

      - name: Run pylint
        working-directory: ./preprocessing
        run: |
          poetry run pylint **/*.py --fail-under=7.0 || true

  # ============================================
  # JOB 2: LINT - Streamlit
  # ============================================
  lint-streamlit:
    name: Lint Streamlit
    runs-on: ubuntu-latest
    needs: [prepare]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Restore Poetry from cache
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: poetry-deps-streamlit-${{ hashFiles('streamlit-poetry-docker/poetry.lock') }}
          restore-keys: poetry-deps-streamlit-

      - name: Update lock file if needed
        working-directory: ./streamlit-poetry-docker
        run: poetry lock --no-interaction

      - name: Install dependencies
        working-directory: ./streamlit-poetry-docker
        run: poetry install --no-root

      - name: Run flake8
        working-directory: ./streamlit-poetry-docker
        run: |
          poetry run flake8 src/ app.py --count --max-line-length=120 --statistics --exclude=.venv,__pycache__,*.pyc,.git

      #- name: Run pylint
      #  working-directory: ./streamlit-poetry-docker
      #  run: |
      #    poetry run pylint src/ app.py --fail-under=7.0 || true

  # ============================================
  # JOB 3: TEST - Preprocessing
  # ============================================
  test-preprocessing:
    name: Test Preprocessing
    runs-on: ubuntu-latest
    needs: [lint-preprocessing]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Restore Poetry from cache
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: poetry-deps-preprocessing-${{ hashFiles('preprocessing/poetry.lock') }}

      - name: Update lock file if needed
        working-directory: ./preprocessing
        run: poetry lock --no-interaction

      - name: Install dependencies
        working-directory: ./preprocessing
        run: poetry install --no-root

      - name: Run pytest with coverage
        working-directory: ./preprocessing
        run: |
          poetry run pytest tests/ --cov=. --cov-report=xml --cov-report=html --cov-report=term || true


  # ============================================
  # JOB 4: TEST - Streamlit
  # ============================================
  test-streamlit:
    name: Test Streamlit
    runs-on: ubuntu-latest
    needs: [lint-streamlit]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Restore Poetry from cache
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: poetry-deps-streamlit-${{ hashFiles('streamlit-poetry-docker/poetry.lock') }}

      - name: Update lock file if needed
        working-directory: ./streamlit-poetry-docker
        run: poetry lock --no-interaction

      - name: Install dependencies
        working-directory: ./streamlit-poetry-docker
        run: poetry install --no-root

      - name: Run pytest with coverage
        working-directory: ./streamlit-poetry-docker
        run: |
          poetry run pytest tests/ --cov=src --cov-report=xml --cov-report=html --cov-report=term || true



   # ============================================
  # JOB 5: TEST - Integration Tests
  # ============================================
  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test-preprocessing, test-streamlit]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install all dependencies
        run: |
          echo "Installing all required dependencies..."
          pip install streamlit pandas numpy scikit-learn plotly pytest pytest-cov pytest-mock
          
          # Install additional dependencies that might be needed
          pip install pyyaml requests matplotlib seaborn

      - name: Create conftest.py for path setup
        run: |
          cat > tests/conftest.py << 'EOF'
          import sys
          import os
          from pathlib import Path
          
          # Get the project root directory
          project_root = Path(__file__).parent.parent
          
          # Add preprocessing module to path
          preprocessing_path = project_root / "preprocessing"
          if preprocessing_path.exists():
              sys.path.insert(0, str(preprocessing_path))
              print(f"Added to path: {preprocessing_path}")
          
          # Add streamlit src module to path
          streamlit_src_path = project_root / "streamlit-poetry-docker"
          if streamlit_src_path.exists():
              sys.path.insert(0, str(streamlit_src_path))
              print(f"Added to path: {streamlit_src_path}")
          else:
              print(f"Warning: streamlit src path not found: {streamlit_src_path}")
          
          print("Python path configured for tests")
          EOF

      - name: Run integration tests with coverage
        run: |
          echo "Running integration tests..."
          pytest tests/ \
            --cov=streamlit-poetry-docker/src \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            -v || echo "Tests completed with issues"
        continue-on-error: false

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: test-coverage-reports
          path: |
            htmlcov/
            coverage.xml
          retention-days: 30
        if: always()

  # ============================================
  # JOB 6: BUILD Sphinx documentation
  # ============================================
  build-documentation:
    name: Build Documentation
    runs-on: ubuntu-latest
    needs: [test-integration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Restore Poetry from cache
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      # Download coverage artifacts from integration tests
      - name: Download integration test coverage
        uses: actions/download-artifact@v4
        with:
          name: test-coverage-reports
          path: ./integration-coverage/
        continue-on-error: true

      - name: Cache preprocessing dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry
          key: poetry-deps-preprocessing-${{ hashFiles('preprocessing/poetry.lock') }}

      - name: Cache streamlit dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pypoetry-streamlit
          key: poetry-deps-streamlit-${{ hashFiles('streamlit-poetry-docker/poetry.lock') }}

      # Build Preprocessing Documentation
      - name: Install preprocessing dependencies
        working-directory: ./preprocessing
        run: |
          poetry install --no-root
          poetry add sphinx sphinx-rtd-theme sphinx-autodoc-typehints

      - name: Build preprocessing documentation
        working-directory: ./preprocessing
        run: |
          # Generate API documentation
          poetry run sphinx-apidoc -o docs/source . --force --module-first --separate
          
          # Build HTML documentation
          poetry run sphinx-build -b html docs/source docs/build/html
        continue-on-error: true

      # Build Streamlit Documentation
      - name: Install streamlit dependencies
        working-directory: ./streamlit-poetry-docker
        run: |
          poetry install --no-root
          poetry add sphinx sphinx-rtd-theme sphinx-autodoc-typehints

      - name: Build streamlit documentation
        working-directory: ./streamlit-poetry-docker
        run: |
          # Generate API documentation
          poetry run sphinx-apidoc -o docs/source src --force --module-first --separate
          
          # Build HTML documentation
          poetry run sphinx-build -b html docs/source docs/build/html
        continue-on-error: true

      # Combine and upload documentation with tests coverage
      - name: Combine documentation with coverage reports
        run: |
          mkdir -p combined-docs
          mkdir -p combined-docs/preprocessing
          mkdir -p combined-docs/streamlit
          mkdir -p combined-docs/coverage
          
          # Copy preprocessing docs
          if [ -d "preprocessing/docs/build/html" ]; then
            cp -r preprocessing/docs/build/html/* combined-docs/preprocessing/ || true
            echo "Preprocessing documentation copied"
          else
            echo "No preprocessing documentation found"
            mkdir -p combined-docs/preprocessing
            echo "<html><body><h1>Preprocessing Documentation</h1><p>Documentation not available</p></body></html>" > combined-docs/preprocessing/index.html
          fi
          
          # Copy streamlit docs
          if [ -d "streamlit-poetry-docker/docs/build/html" ]; then
            cp -r streamlit-poetry-docker/docs/build/html/* combined-docs/streamlit/ || true
            echo "Streamlit documentation copied"
          else
            echo "No streamlit documentation found"
            mkdir -p combined-docs/streamlit
            echo "<html><body><h1>Streamlit Documentation</h1><p>Documentation not available</p></body></html>" > combined-docs/streamlit/index.html
          fi
          
          # Copy integration test coverage reports
          if [ -d "integration-coverage/htmlcov" ]; then
            cp -r integration-coverage/htmlcov/* combined-docs/coverage/ || true
            echo "Integration test coverage copied"
          else
            echo "No integration coverage found, creating placeholder"
            mkdir -p combined-docs/coverage
            cat > combined-docs/coverage/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>Coverage Report</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; }
                  .container { max-width: 600px; margin: 0 auto; }
                  .message { padding: 20px; background-color: #f8f9fa; border-radius: 8px; }
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>Coverage Report</h1>
                  <div class="message">
                      <p> Coverage report not available</p>
                      <p>Integration tests may not have generated coverage data.</p>
                  </div>
              </div>
          </body>
          </html>
          EOF
          fi
          
          # Copy coverage badge if available
          if [ -f "integration-coverage/coverage.svg" ]; then
            cp integration-coverage/coverage.svg combined-docs/coverage/ || true
            echo "Coverage badge copied"
          fi
          
          # Create enhanced index page with coverage
          cat > combined-docs/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>MangeTaMain : Documentation du projet</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; background-color: #f8f9fa; }
                  .container { max-width: 1000px; margin: 0 auto; }
                  .card { 
                      background: white; 
                      border: 1px solid #ddd; 
                      border-radius: 8px; 
                      padding: 20px; 
                      margin: 20px 0; 
                      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                  }
                  .header { text-align: center; margin-bottom: 40px; }
                  h1 { color: #333; margin: 0; }
                  h2 { color: #555; margin-top: 0; }
                  .subtitle { color: #666; margin-top: 10px; }
                  a { color: #007bff; text-decoration: none; margin-right: 15px; }
                  a:hover { text-decoration: underline; }
                  .links { margin-top: 15px; }
                  .coverage-badge { margin-top: 10px; }
                  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
                  .full-width { grid-column: 1 / -1; }
                  @media (max-width: 768px) { 
                      .grid { grid-template-columns: 1fr; }
                      .full-width { grid-column: 1; }
                  }
                  .status-indicator {
                      display: inline-block;
                      width: 12px;
                      height: 12px;
                      border-radius: 50%;
                      margin-right: 8px;
                  }
                  .status-success { background-color: #28a745; }
                  .status-warning { background-color: #ffc107; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1> MangeTaMain : Documentation du projet</h1>
                      <p class="subtitle">Syst√®me de recommandation de recettes personnalis√©es</p>
                  </div>
                  
                  <div class="grid">
                      <div class="card">
                          <h2><span class="status-indicator status-success"></span> Module Preprocessing</h2>
                          <p>Pr√©paration des donn√©es, feature engineering et entra√Ænement des mod√®les.</p>
                          <div class="links">
                              <a href="preprocessing/index.html">üìñ Documentation API</a>
                          </div>
                      </div>
                      
                      <div class="card">
                          <h2><span class="status-indicator status-success"></span>Application Streamlit</h2>
                          <p>Interface utilisateur et moteur de recommandation.</p>
                          <div class="links">
                              <a href="streamlit/index.html"> Documentation API</a>
                          </div>
                      </div>
                      
                      <div class="card full-width">
                          <h2><span class="status-indicator status-success"></span>Rapport de couverture des tests</h2>
                          <p>Rapports de tests d'int√©gration et couverture de code.</p>
                          <div class="coverage-badge">
                              <img src="coverage/coverage.svg" alt="Test Coverage" style="margin-right: 10px;" onerror="this.style.display='none'">
                          </div>
                          <div class="links">
                              <a href="coverage/index.html">Rapport de Couverture</a>
                          </div>
                      </div>
                      
                     
                  </div>
              
              </div>
          </body>
          </html>
          EOF
          
          echo "Documentation combined successfully"
          echo "Combined docs structure:"
          find combined-docs -type f -name "*.html" | head -10

      - name: Upload documentation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: documentation
          path: combined-docs/
          retention-days: 30

      # Deploy to GitHub Pages (if on main branch)
      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.REPO_TOKEN }}
          publish_dir: ./combined-docs
          force_orphan: true



  # ============================================
  # JOB 7: DEPLOY TO RAILWAY VIA API
  # ============================================
  deploy-railway:
    name: Deploy to Railway via API
    runs-on: ubuntu-latest
    #needs: [build-documentation]  # Commented out to run independently
    #if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get Railway Project Info
        id: railway-info
        run: |
          # Use project ID from secrets and get environment/service info
          PROJECT_ID="${{ secrets.RAILWAY_PROJECT_ID }}"
          echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_OUTPUT
          
          # Get project details using Railway GraphQL API with API token
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.RAILWAY_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "query($projectId: String!) { project(id: $projectId) { environments { edges { node { id name } } } services { edges { node { id name } } } } }",
              "variables": { "projectId": "'$PROJECT_ID'" }
            }' \
            https://backboard.railway.app/graphql)
          
          echo "Railway API Response:"
          echo "$RESPONSE"
          
          # Check if response is valid JSON
          if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
            echo "‚ùå Invalid JSON response from Railway API"
            echo "Raw response: $RESPONSE"
            exit 1
          fi
          
          # Extract production environment ID
          ENV_ID=$(echo "$RESPONSE" | jq -r '.data.project.environments.edges[] | select(.node.name == "production") | .node.id' 2>/dev/null || echo "")
          if [ -z "$ENV_ID" ]; then
            echo "‚ùå Could not find production environment ID"
            echo "Available environments:"
            echo "$RESPONSE" | jq -r '.data.project.environments.edges[].node | "\(.name): \(.id)"' 2>/dev/null || echo "Failed to parse environments"
            exit 1
          fi
          echo "ENV_ID=$ENV_ID" >> $GITHUB_OUTPUT
          
          # Extract service ID (first service)
          SERVICE_ID=$(echo "$RESPONSE" | jq -r '.data.project.services.edges[0].node.id' 2>/dev/null || echo "")
          if [ -z "$SERVICE_ID" ]; then
            echo "‚ùå Could not find service ID"
            echo "Available services:"
            echo "$RESPONSE" | jq -r '.data.project.services.edges[].node | "\(.name): \(.id)"' 2>/dev/null || echo "Failed to parse services"
            exit 1
          fi
          echo "SERVICE_ID=$SERVICE_ID" >> $GITHUB_OUTPUT

      - name: Trigger Railway Deployment
        run: |
          echo "Triggering deployment with:"
          echo "Project ID: ${{ steps.railway-info.outputs.PROJECT_ID }}"
          echo "Environment ID: ${{ steps.railway-info.outputs.ENV_ID }}"
          echo "Service ID: ${{ steps.railway-info.outputs.SERVICE_ID }}"
          
          # Trigger deployment using GraphQL mutation with API token
          DEPLOY_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.RAILWAY_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "mutation deploymentCreate($input: DeploymentCreateInput!) { deploymentCreate(input: $input) { id url status } }",
              "variables": {
                "input": {
                  "environmentId": "${{ steps.railway-info.outputs.ENV_ID }}",
                  "serviceId": "${{ steps.railway-info.outputs.SERVICE_ID }}",
                  "meta": {
                    "branch": "${{ github.ref_name }}",
                    "commitSha": "${{ github.sha }}",
                    "repo": "${{ github.repository }}"
                  }
                }
              }
            }' \
            https://backboard.railway.app/graphql)
          
          echo "Deployment Response:"
          echo "$DEPLOY_RESPONSE" | jq '.'
          
          # Extract deployment ID and URL
          DEPLOYMENT_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.data.deploymentCreate.id')
          DEPLOYMENT_URL=$(echo "$DEPLOY_RESPONSE" | jq -r '.data.deploymentCreate.url')
          
          echo "‚úÖ Deployment initiated!"
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo "Deployment URL: $DEPLOYMENT_URL"
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}

      - name: Wait for deployment
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: |
          echo "Waiting for deployment to complete..."
          
          # Set Railway token for authentication
          export RAILWAY_TOKEN="${{ secrets.RAILWAY_TOKEN }}"
          
          # Wait for deployment to be ready (max 5 minutes)
          timeout=300
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if railway status | grep -q "RUNNING"; then
              echo "Deployment completed successfully!"
              break
            fi
            
            echo "Still deploying... ($elapsed/$timeout seconds)"
            sleep 20
            elapsed=$((elapsed + 20))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "Deployment timeout after $timeout seconds"
            railway status
            exit 1
          fi

      - name: Health check
        run: |
          echo "Performing health check..."
          
          # Wait a bit for Railway to fully start the service
          sleep 30
          
          # Health check with retry logic
          max_attempts=6
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            attempt=$((attempt + 1))
            
            echo "Health check attempt $attempt/$max_attempts"
            
            if curl -f -s --max-time 30 "${{ secrets.RAILWAY_APP_URL }}/_stcore/health" > /dev/null; then
              echo "Health check passed! App is healthy."
              break
            fi
            
            if [ $attempt -eq $max_attempts ]; then
              echo "Health check failed after $max_attempts attempts"
              echo "Try accessing manually: ${{ secrets.RAILWAY_APP_URL }}"
              exit 1
            fi
            
            echo "Health check failed, retrying in 20 seconds..."
            sleep 20
          done

